<!DOCTYPE html>
<html>
<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js"></script>
  <script src="http://drsstein.github.io/pyjamas/v0.1/pjs.js"></script>
</head>

<body>
<h1>Interactive Python</h1>
<h2>Canvas</h2>
<svg id="figure" width="800" height="800" style="border: 1px solid black;"></svg>

<p id="output"></p>
<div id="status""></div><br>

<h2>Terminal</h2>
<div id="terminal"></div>

<script>

function update_simulation() {
    // update physics simulation
    pjs.run("agent.step(mouse[1])").then(() => {
            agent_positions = pjs.get("agent.x").toJs();
            for (let i = 0; i < agent_positions.length; i++) {
                agent = document.getElementById("agent_"+i);
                agent.setAttribute("cy", Math.trunc( agent_positions[i] ));
            }
        })
}

async function main_spring() {
    // set "status" as the standard output DOM element.
    await pjs.init("status"); 
    // create a python interpeter inside the "terminal" DOM element.
    await pjs.terminal("terminal");
    
    // run script
    // todo: load from file inside pjs
    const init_script = `
import numpy as np

class MassSpringOscillator():
    
    def __init__(self, num_objects, bounds):
        self.num_objects = num_objects
        self.bounds = bounds
        self.k = 0.5 # spring constant
        self.b = 0.1 # damping constant
        self.dt = 0.05 # simulation time per update call
        
    def reset(self):
        self.m = 0.5 + np.random.uniform(size=self.num_objects) * 2
        self.x = 0
        self.v = 0
        return self.x
        
    def step(self, action):
        self.anchor = action
        dx = self.x - self.anchor
        f_spring = -self.k * dx
        f_friction = -self.b * self.v
        f_total = f_spring + f_friction
        a = f_total / self.m
        self.v = self.v + self.dt * a
        x = self.x + self.dt * self.v
        is_below = x < self.bounds[0]
        x[is_below] = self.bounds[0] - x[is_below]
        self.v[is_below] = -self.v[is_below]
        
        is_above = x > self.bounds[1]
        x[is_above] = 2*self.bounds[1] - x[is_above]
        self.v[is_above] = -self.v[is_above]
        
        self.x = x
        return self.x
        
agent = MassSpringOscillator(num_objects=20, bounds=[0, 800])
mouse = [0,0]
agent.reset()
    `;
    await pjs.run(init_script);
    
    // create object representations
    var svg = document.getElementById("figure");
    const num_objects = pjs.get("agent.num_objects");
    const width = svg.width.baseVal.value; //svg.getBBox().width;
    const distance = Math.trunc( width / (num_objects + 1) );
    for (var i = 0; i < num_objects; i++) {
        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute('cx', (i+1) * distance);
        circle.setAttribute('cy', 0);
        circle.setAttribute('r', 10);
        circle.setAttribute('id', "agent_"+i);
        // random color
        circle.setAttribute('style', 'fill: #'+Math.floor(Math.random()*16777215).toString(16) );
        svg.appendChild(circle);
    }
    
    //attach mouse callback to svg
    svg.onmousemove = function(event){
        const box = event.currentTarget.getBoundingClientRect();
        const mouse = [
            event.clientX - box.left,
            event.clientY - box.top
        ];
        pjs.run("mouse = np.array([" + mouse.toString() + "])")
    };
    
    // start update loop
    setInterval(update_simulation, 10);
}

main_spring();

</script>

</body>
</html>